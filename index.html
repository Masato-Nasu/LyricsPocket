<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#0b0e14"/>
<link rel="manifest" href="./manifest.webmanifest">
<title>LyricsPocket</title>

<!-- OneFileReset v1: no external JS required; SW reset + cache reset to escape "white SW" loops -->
<script>
(async function(){
  try {
    // Run only once per session
    if (sessionStorage.getItem("lp_onefile_reset_done")) return;
    sessionStorage.setItem("lp_onefile_reset_done","1");

    // Unregister any SW controlling this origin (best effort)
    if ("serviceWorker" in navigator) {
      const regs = await navigator.serviceWorker.getRegistrations();
      await Promise.all(regs.map(r => r.unregister()));
    }
    // Clear caches (best effort)
    if ("caches" in window) {
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }
    // Do NOT auto-reload endlessly; just mark
  } catch(e) {}
})();
</script>

<style>
:root{
  --bg:#0b0e14; --fg:rgba(255,255,255,.92); --muted:rgba(255,255,255,.65);
  --line:rgba(255,255,255,.14); --chip:rgba(255,255,255,.08);
  --chipOn:rgba(160,220,255,.18);
  --r:14px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background:var(--bg); color:var(--fg);
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Yu Gothic UI",Meiryo,sans-serif;
}
.wrap{max-width:980px; margin:0 auto; padding:14px 14px 120px;}
.top{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
.title{font-weight:700; letter-spacing:.02em;}
.chips{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
.chip{
  padding:8px 10px; border-radius:999px; background:var(--chip);
  border:1px solid var(--line); color:var(--fg); font-size:12px; user-select:none;
}
.chip.on{background:var(--chipOn); border-color:rgba(160,220,255,.35);}
.status{margin-top:10px; padding:10px 12px; border:1px solid var(--line); border-radius:var(--r); color:var(--muted); font-size:12px;}
.pane{margin-top:12px; border:1px solid var(--line); border-radius:var(--r); overflow:hidden;}
.pane .head{padding:10px 12px; background:rgba(255,255,255,.04); border-bottom:1px solid var(--line); font-size:12px; color:var(--muted);}
.pane .body{padding:10px 12px;}
.row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
/* File input styling (Chrome/Android) */
input[type=file]{color:var(--muted);}
input[type=file]::file-selector-button{
  border:1px solid var(--line);
  background:rgba(255,255,255,.06);
  color:var(--fg);
  padding:9px 12px;
  border-radius:12px;
  cursor:pointer;
}
input[type=file]::file-selector-button:hover{background:rgba(255,255,255,.09);}
.btn{
  border:1px solid var(--line);
  background:rgba(255,255,255,.06);
  color:var(--fg);
  padding:10px 14px;
  border-radius:12px;
  cursor:pointer;
  font:inherit;
}
.btn:active{transform:translateY(1px)}
.btn.secondary{background:rgba(255,255,255,.03)}
hr{border:none; border-top:1px solid var(--line); margin:12px 0}
.lineBox{display:flex; flex-direction:column; gap:8px;}
.currentEn{font-size:16px; line-height:1.35}
.currentJp{font-size:14px; color:rgba(180,220,255,.9); line-height:1.35}
.list{max-height:46vh; overflow:auto; border-top:1px solid var(--line);}
.item{padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.07); cursor:pointer;}
.item .t{font-size:14px; line-height:1.35}
.item .jp{margin-top:6px; font-size:13px; line-height:1.35; color:rgba(180,220,255,.9); display:none}
.item.current{background:rgba(255,255,255,.04)}
.item.showjp .jp{display:block}
.footerBar{
  position:fixed; left:0; right:0; bottom:0;
  background:rgba(11,14,20,.92); backdrop-filter: blur(10px);
  border-top:1px solid var(--line);
}
.footerBar .inner{max-width:980px; margin:0 auto; padding:10px 14px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
.small{font-size:12px; color:var(--muted);}
#errPanel{
  position:fixed; left:12px; right:12px; bottom:12px;
  max-height:42vh; overflow:auto;
  background:rgba(0,0,0,.84);
  border:1px solid rgba(255,255,255,.18);
  color:rgba(255,255,255,.92);
  padding:10px 12px;
  border-radius:12px;
  font-size:12px;
  line-height:1.35;
  z-index:99999;
  display:none;
  white-space:pre-wrap;
}
#errPanel .t{font-weight:700; margin-bottom:6px;}
</style>
</head>

<body>
<div class="wrap">
  <div class="top">
    <div class="title">LyricsPocket</div>
    <div class="chips">
      <span class="chip" style="opacity:.7">OneFileReset v1</span>
      <button id="btnOnline" class="chip" type="button">ONLINE JP: OFF</button>
      <a class="chip" href="./kill-sw.html" style="text-decoration:none;color:inherit">SW RESET</a>
    </div>
  </div>

  <div id="status" class="status">READY</div>

  <div class="pane">
    <div class="head">IMPORT</div>
    <div class="body">
      <div class="row">
        <input id="inFolder" type="file" webkitdirectory multiple />
        <input id="inAudio" type="file" accept="audio/*,.mp3,.m4a,.aac,.wav,.flac,.ogg" multiple />
        <input id="inLyrics" type="file" accept=".lrc,.txt,text/plain" multiple />
      </div>
      <div class="small" style="margin-top:8px">
        iPhone(iOS)ではフォルダ選択が非対応のため、FILES/LYRICSで複数選択してください。
      </div>
    </div>
  </div>

  <div class="pane">
    <div class="head">NOW</div>
    <div class="body">
      <div class="lineBox">
        <div id="curEn" class="currentEn">TAP A LINE TO TRANSLATE</div>
        <div id="curJp" class="currentJp"></div>
      </div>
      <hr>
      <div class="row">
        <button id="btnPlay" class="btn" type="button">PLAY</button>
        <button id="btnPrev" class="btn secondary" type="button">PREV</button>
        <button id="btnNext" class="btn secondary" type="button">NEXT</button>
        <button id="btnList" class="btn secondary" type="button">LIST</button>
      </div>
      <audio id="audio" preload="metadata" playsinline></audio>
    </div>
    <div id="list" class="list" style="display:none"></div>
  </div>
</div>

<div id="errPanel"><div class="t">APP ERROR</div><div id="errText"></div></div>

<script>
(function(){
  const errPanel = document.getElementById("errPanel");
  const errText = document.getElementById("errText");
  function showErr(msg){
    errPanel.style.display = "block";
    errText.textContent = String(msg);
  }
  window.addEventListener("error", (e)=>showErr(e?.message || String(e?.error || "Unknown error")));
  window.addEventListener("unhandledrejection", (e)=>showErr("Unhandled Promise Rejection:\n"+String(e?.reason || "Unknown")));
})();
</script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const status = $("status");
  const btnOnline = $("btnOnline");
  const inFolder = $("inFolder");
  const inAudio = $("inAudio");
  const inLyrics = $("inLyrics");

  const btnPlay = $("btnPlay");
  const btnPrev = $("btnPrev");
  const btnNext = $("btnNext");
  const btnList = $("btnList");

  const audio = $("audio");
  const listEl = $("list");
  const curEn = $("curEn");
  const curJp = $("curJp");

  let onlineJP = false;

  /** Tracks: {name, url} */
  let tracks = [];
  let trackIndex = -1;

  /** Lyrics: array of {t:number, text:string, jp?:string} sorted by t */
  let lyricLines = [];
  let currentLineIndex = -1;

  const lyricsByBase = new Map(); // baseName -> text content

  function setStatus(t) { status.textContent = t; }

  function baseName(filename) {
    const n = (filename || "").split("/").pop();
    if (!n) return "";
    const dot = n.lastIndexOf(".");
    return (dot>=0 ? n.slice(0,dot) : n).toLowerCase();
  }

  function parseLRC(text) {
    const out = [];
    const lines = (text || "").replace(/\r/g,"").split("\n");
    const timeRe = /\[(\d{1,2}):(\d{2})(?:\.(\d{1,3}))?\]/g;
    for (const raw of lines) {
      const line = raw.trim();
      if (!line) continue;
      let m;
      let lastIdx = 0;
      const times = [];
      while ((m = timeRe.exec(line))) {
        const mm = Number(m[1]);
        const ss = Number(m[2]);
        const ms = m[3] ? Number(m[3].padEnd(3,"0")) : 0;
        times.push(mm*60 + ss + ms/1000);
        lastIdx = timeRe.lastIndex;
      }
      if (!times.length) continue;
      const txt = line.slice(lastIdx).trim();
      if (!txt) continue;
      for (const t of times) out.push({t, text:txt});
    }
    out.sort((a,b)=>a.t-b.t);
    return out;
  }

  function renderList() {
    listEl.innerHTML = "";
    for (let i=0;i<lyricLines.length;i++) {
      const li = lyricLines[i];
      const div = document.createElement("div");
      div.className = "item" + (i===currentLineIndex ? " current": "");
      div.dataset.i = String(i);
      div.innerHTML = `<div class="t">${escapeHTML(li.text)}</div><div class="jp"></div>`;
      div.addEventListener("click", () => {
        jumpToLine(i);
        translateLine(i);
      });
      listEl.appendChild(div);
    }
  }

  function escapeHTML(s) {
    return String(s).replace(/[&<>]/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]));
  }

  function pickLyricsForTrack(name) {
    const b = baseName(name);
    const txt = lyricsByBase.get(b);
    if (!txt) return false;
    lyricLines = parseLRC(txt);
    currentLineIndex = -1;
    renderList();
    setStatus(`LYRICS LOADED: ${lyricLines.length} lines`);
    return true;
  }

  function importLyricsFiles(files) {
    let n = 0;
    for (const f of files) {
      const ext = (f.name.split(".").pop() || "").toLowerCase();
      if (ext !== "lrc" && ext !== "txt") continue;
      n++;
      const reader = new FileReader();
      reader.onload = () => {
        const txt = String(reader.result || "");
        lyricsByBase.set(baseName(f.name), txt);
        setStatus(`LYRICS READY: ${lyricsByBase.size} files`);
        // auto-attach if a track is already selected
        if (trackIndex>=0) pickLyricsForTrack(tracks[trackIndex].name);
      };
      reader.readAsText(f);
    }
    if (!n) setStatus("NO LYRICS FOUND");
  }

  function importAudioFiles(files) {
    const list = [];
    for (const f of files) {
      if (!f.type.startsWith("audio/") && !/\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(f.name)) continue;
      list.push({name:f.name, url:URL.createObjectURL(f)});
    }
    if (!list.length) {
      setStatus("NO AUDIO FOUND");
      return;
    }
    tracks = list;
    trackIndex = 0;
    setStatus(`FILES LOADED: ${tracks.length}`);
    selectTrack(0, true);
  }

  function selectTrack(i, autoPlay=false) {
    if (i<0 || i>=tracks.length) return;
    trackIndex = i;
    const tr = tracks[trackIndex];
    audio.pause();
    audio.src = tr.url;
    audio.load();
    curEn.textContent = "TAP A LINE TO TRANSLATE";
    curJp.textContent = "";
    currentLineIndex = -1;
    // auto pick lyrics
    pickLyricsForTrack(tr.name);
    setStatus(`TRACK: ${tr.name}`);
    if (autoPlay) safePlay();
  }

  async function safePlay() {
    try {
      await audio.play();
      setStatus(`PLAYING: ${tracks[trackIndex]?.name || ""}`);
      return true;
    } catch(e) {
      const msg = String(e?.message || e || "");
      setStatus("PLAY FAILED: " + msg);
      alert("再生できません: " + msg + "\n\n(一度画面をタップしてからPLAYを押してください)");
      return false;
    }
  }

  function findLineIndexByTime(t) {
    if (!lyricLines.length) return -1;
    // last line with time <= t
    let lo=0, hi=lyricLines.length-1, ans=-1;
    while (lo<=hi) {
      const mid=(lo+hi)>>1;
      if (lyricLines[mid].t <= t) { ans=mid; lo=mid+1; } else { hi=mid-1; }
    }
    return ans;
  }

  function highlight(i) {
    if (i===currentLineIndex) return;
    currentLineIndex = i;
    const children = Array.from(listEl.children);
    children.forEach((el, idx) => {
      el.classList.toggle("current", idx===i);
    });
    if (i>=0 && lyricLines[i]) {
      curEn.textContent = lyricLines[i].text;
      if (onlineJP) translateLine(i);
    }
  }

  function jumpToLine(i) {
    if (!lyricLines[i]) return;
    audio.currentTime = Math.max(0, lyricLines[i].t + 0.01);
    highlight(i);
  }

  async function translateText(en) {
    // MyMemory (free). If blocked, fallback to empty.
    const url = "https://api.mymemory.translated.net/get?q=" + encodeURIComponent(en) + "&langpair=en|ja";
    const res = await fetch(url, {cache:"no-store"});
    const data = await res.json();
    const jp = data?.responseData?.translatedText;
    return (jp && typeof jp==="string") ? jp : "";
  }

  async function translateLine(i) {
    if (!onlineJP) return;
    const li = lyricLines[i];
    if (!li || !li.text) return;
    if (li.jp) {
      curJp.textContent = li.jp;
      const row = listEl.children[i];
      if (row) {
        row.classList.add("showjp");
        row.querySelector(".jp").textContent = li.jp;
      }
      return;
    }
    curJp.textContent = "TRANSLATING...";
    try {
      const jp = await translateText(li.text);
      li.jp = jp || "";
      curJp.textContent = li.jp || "";
      const row = listEl.children[i];
      if (row) {
        row.classList.add("showjp");
        row.querySelector(".jp").textContent = li.jp || "";
      }
    } catch(e) {
      curJp.textContent = "";
      setStatus("TRANSLATE FAILED");
    }
  }

  // EVENTS
  btnOnline.addEventListener("click", () => {
    onlineJP = !onlineJP;
    btnOnline.textContent = "ONLINE JP: " + (onlineJP ? "ON" : "OFF");
    btnOnline.classList.toggle("on", onlineJP);
    if (!onlineJP) {
      curJp.textContent = "";
    } else {
      // translate current line if any
      if (currentLineIndex>=0) translateLine(currentLineIndex);
    }
  });

  inFolder.addEventListener("change", async () => {
    const files = Array.from(inFolder.files || []);
    importAudioFiles(files);
    importLyricsFiles(files);
    inFolder.value = "";
  });

  inAudio.addEventListener("change", async () => {
    const files = Array.from(inAudio.files || []);
    importAudioFiles(files);
    inAudio.value = "";
  });

  inLyrics.addEventListener("change", async () => {
    const files = Array.from(inLyrics.files || []);
    importLyricsFiles(files);
    inLyrics.value = "";
  });

  btnPlay.addEventListener("click", async () => {
    if (!tracks.length) { alert("まずFILESで音声ファイルを選択してください。"); return; }
    if (audio.paused) await safePlay();
    else {
      audio.pause();
      setStatus("PAUSED");
    }
  });

  btnPrev.addEventListener("click", () => {
    if (!tracks.length) return;
    selectTrack((trackIndex-1+tracks.length)%tracks.length, true);
  });

  btnNext.addEventListener("click", () => {
    if (!tracks.length) return;
    selectTrack((trackIndex+1)%tracks.length, true);
  });

  btnList.addEventListener("click", () => {
    const show = listEl.style.display !== "none";
    listEl.style.display = show ? "none" : "block";
  });

  audio.addEventListener("timeupdate", () => {
    if (!lyricLines.length) return;
    const i = findLineIndexByTime(audio.currentTime);
    if (i>=0) highlight(i);
  });

  audio.addEventListener("error", () => {
    setStatus("AUDIO ERROR");
  });

  setStatus("READY (OneFileReset v1)");
})();
</script>

</body>
</html>
