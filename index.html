<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#0b0e14"/>
<link rel="manifest" href="./manifest.webmanifest">
<title>LyricsPocket</title>

<!-- OneFileReset v2: No external JS/CSS (avoids SW/cache issues). Includes SW+Cache reset tools. -->
<script>
(async function(){
  try{
    if (sessionStorage.getItem("lp_onefile_reset_v2_done")) return;
    sessionStorage.setItem("lp_onefile_reset_v2_done","1");
    if ("serviceWorker" in navigator){
      const regs = await navigator.serviceWorker.getRegistrations();
      await Promise.all(regs.map(r=>r.unregister()));
    }
    if ("caches" in window){
      const keys = await caches.keys();
      await Promise.all(keys.map(k=>caches.delete(k)));
    }
  }catch(e){}
})();
</script>

<style>
:root{
  --bg:#0b0e14; --fg:rgba(255,255,255,.92); --muted:rgba(255,255,255,.65);
  --line:rgba(255,255,255,.14); --chip:rgba(255,255,255,.08);
  --chipOn:rgba(160,220,255,.18);
  --r:14px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0; background:var(--bg); color:var(--fg);
  font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,"Hiragino Kaku Gothic ProN","Yu Gothic UI",Meiryo,sans-serif;
}
.wrap{max-width:980px; margin:0 auto; padding:14px 14px 130px;}
.top{display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;}
.title{font-weight:700; letter-spacing:.02em;}
.chips{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
.chip{
  padding:8px 10px; border-radius:999px; background:var(--chip);
  border:1px solid var(--line); color:var(--fg); font-size:12px; user-select:none;
}
button.chip{cursor:pointer}
.chip.on{background:var(--chipOn); border-color:rgba(160,220,255,.35);}
.status{margin-top:10px; padding:10px 12px; border:1px solid var(--line); border-radius:var(--r); color:var(--muted); font-size:12px;}
.pane{margin-top:12px; border:1px solid var(--line); border-radius:var(--r); overflow:hidden;}
.pane .head{padding:10px 12px; background:rgba(255,255,255,.04); border-bottom:1px solid var(--line); font-size:12px; color:var(--muted);}
.pane .body{padding:10px 12px;}
.row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
input[type=file]{color:var(--muted);}
input[type=file]::file-selector-button{
  border:1px solid var(--line);
  background:rgba(255,255,255,.06);
  color:var(--fg);
  padding:9px 12px;
  border-radius:12px;
  cursor:pointer;
}
input[type=file]::file-selector-button:hover{background:rgba(255,255,255,.09);}
select{
  border:1px solid var(--line);
  background:rgba(255,255,255,.06);
  color:var(--fg);
  padding:10px 12px;
  border-radius:12px;
  min-width:240px;
}
.btn{
  border:1px solid var(--line);
  background:rgba(255,255,255,.06);
  color:var(--fg);
  padding:10px 14px;
  border-radius:12px;
  cursor:pointer;
  font:inherit;
}
.btn.secondary{background:rgba(255,255,255,.03)}
.btn:active{transform:translateY(1px)}
hr{border:none; border-top:1px solid var(--line); margin:12px 0}
.lineBox{display:flex; flex-direction:column; gap:8px;}
.currentEn{font-size:16px; line-height:1.35}
.currentJp{font-size:14px; color:rgba(180,220,255,.9); line-height:1.35}
.list{max-height:46vh; overflow:auto; border-top:1px solid var(--line);}
.item{padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.07); cursor:pointer;}
.item .t{font-size:14px; line-height:1.35}
.item .jp{margin-top:6px; font-size:13px; line-height:1.35; color:rgba(180,220,255,.9); display:none}
.item.current{background:rgba(255,255,255,.04)}
.item.showjp .jp{display:block}

#errPanel{
  position:fixed; left:12px; right:12px; bottom:12px;
  max-height:42vh; overflow:auto;
  background:rgba(0,0,0,.84);
  border:1px solid rgba(255,255,255,.18);
  color:rgba(255,255,255,.92);
  padding:10px 12px;
  border-radius:12px;
  font-size:12px;
  line-height:1.35;
  z-index:99999;
  display:none;
  white-space:pre-wrap;
}
#errPanel .t{font-weight:700; margin-bottom:6px;}
.small{font-size:12px; color:var(--muted);}
a{color:rgba(160,220,255,.95)}
</style>
</head>

<body>
<div class="wrap">
  <div class="top">
    <div class="title">LyricsPocket</div>
    <div class="chips">
      <span class="chip" style="opacity:.7">OneFileReset v2</span>
      <button id="btnOnline" class="chip on" type="button">ONLINE JP: ON</button>
      <button id="btnList" class="chip" type="button">LIST: ON</button>
      <a class="chip" href="./kill-sw.html" style="text-decoration:none;color:inherit">SW RESET</a>
    </div>
  </div>

  <div id="status" class="status">READY</div>

  <div class="pane">
    <div class="head">IMPORT</div>
    <div class="body">
      <div class="row">
        <input id="inFolder" type="file" webkitdirectory multiple />
        <input id="inAudio" type="file" accept="audio/*,.mp3,.m4a,.aac,.wav,.flac,.ogg" multiple />
        <input id="inLyrics" type="file" accept=".lrc,.txt,text/plain" multiple />
      </div>
      <div class="small" style="margin-top:8px">
        iPhone(iOS)ではフォルダ選択が非対応のため、FILES/LYRICSで複数選択してください。<br>
        ※歌詞は .lrc（タイムタグ）推奨。 .txt（タイム無し）も表示は可能（自動追従は不可）です。
      </div>
      <hr>
      <div class="row">
        <select id="selTrack">
          <option value="">TRACK: (未選択)</option>
        </select>
      </div>
    </div>
  </div>

  <div class="pane">
    <div class="head">NOW</div>
    <div class="body">
      <div class="lineBox">
        <div id="curEn" class="currentEn">TAP A LINE TO TRANSLATE</div>
        <div id="curJp" class="currentJp"></div>
      </div>
      <hr>
      <div class="row">
        <button id="btnPlay" class="btn" type="button">PLAY</button>
        <button id="btnPrev" class="btn secondary" type="button">PREV</button>
        <button id="btnNext" class="btn secondary" type="button">NEXT</button>
        <button id="btnOpen" class="btn secondary" type="button">OPEN</button>
        <button id="btnCopy" class="btn secondary" type="button">COPY</button>
      </div>
      <audio id="audio" preload="metadata" playsinline></audio>
    </div>
    <div id="list" class="list"></div>
  </div>
</div>

<div id="errPanel"><div class="t">APP ERROR</div><div id="errText"></div></div>

<script>
(function(){
  const errPanel = document.getElementById("errPanel");
  const errText = document.getElementById("errText");
  function showErr(msg){
    errPanel.style.display = "block";
    errText.textContent = String(msg);
  }
  window.addEventListener("error", (e)=>showErr(e?.message || String(e?.error || "Unknown error")));
  window.addEventListener("unhandledrejection", (e)=>showErr("Unhandled Promise Rejection:\n"+String(e?.reason || "Unknown")));
})();
</script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const status = $("status");
  const btnOnline = $("btnOnline");
  const btnList = $("btnList");
  const btnPlay = $("btnPlay");
  const btnPrev = $("btnPrev");
  const btnNext = $("btnNext");
  const btnOpen = $("btnOpen");
  const btnCopy = $("btnCopy");

  const inFolder = $("inFolder");
  const inAudio = $("inAudio");
  const inLyrics = $("inLyrics");

  const selTrack = $("selTrack");
  const audio = $("audio");
  const listEl = $("list");
  const curEn = $("curEn");
  const curJp = $("curJp");

  let onlineJP = true;
  let listOn = true;

  let tracks = []; // {name, url}
  let trackIndex = -1;

  let lyricLines = []; // {t:number|null, text, jp?}
  let currentLineIndex = -1;

  const lyricsByBase = new Map(); // baseName -> text

  function setStatus(t){ status.textContent = t; }

  function escapeHTML(s){
    return String(s).replace(/[&<>]/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;" }[c]));
  }

  function baseName(filename){
    const n = (filename || "").split("/").pop();
    if (!n) return "";
    const dot = n.lastIndexOf(".");
    return (dot>=0 ? n.slice(0,dot) : n).toLowerCase();
  }

  function normalizeKey(name){
    return (name || "").toLowerCase()
      .replace(/\.[a-z0-9]+$/i,"")
      .split("/").pop()
      .replace(/\[[^\]]*\]/g,"")
      .replace(/\([^\)]*\)/g,"")
      .replace(/feat\..*$/i,"")
      .replace(/-\s*remaster.*$/i,"")
      .replace(/\s+remaster.*$/i,"")
      .replace(/[^a-z0-9]+/g,"");
  }

  function parseLyrics(text){
    const raw = (text || "").replace(//g,"");
    const lines = raw.split("
");
    const out = [];
    const timeRe = /\[(\d{1,2}):(\d{2})(?:\.(\d{1,3}))?\]/g;
    const hasTime = /\[\d{1,2}:\d{2}(?:\.\d{1,3})?\]/.test(raw);

    if (hasTime){
      for (const r of lines){
        const line = r.trim();
        if (!line) continue;
        let m, lastIdx = 0;
        const times = [];
        while ((m = timeRe.exec(line))){
          const mm = Number(m[1]);
          const ss = Number(m[2]);
          const ms = m[3] ? Number(m[3].padEnd(3,"0")) : 0;
          times.push(mm*60 + ss + ms/1000);
          lastIdx = timeRe.lastIndex;
        }
        if (!times.length) continue;
        const txt = line.slice(lastIdx).trim();
        if (!txt) continue;
        for (const t of times) out.push({ t, text: txt });
      }
      out.sort((a,b)=>a.t-b.t);
      return out;
    }

    // plain text (no timestamps)
    for (const r of lines){
      const line = r.trim();
      if (!line) continue;
      out.push({ t: null, text: line });
    }
    return out;
  }

  function renderList(){
    listEl.innerHTML = "";
    if (!lyricLines.length){
      const div = document.createElement("div");
      div.className = "item";
      div.style.cursor = "default";
      div.innerHTML = `<div class="t" style="opacity:.75">歌詞が見つかりません。<br>・LYRICSで .lrc / .txt を読み込んでください<br>・曲名と歌詞ファイル名を一致させると自動で紐づきます</div>`;
      listEl.appendChild(div);
      return;
    }
    for (let i=0;i<lyricLines.length;i++){
      const li = lyricLines[i];
      const div = document.createElement("div");
      div.className = "item" + (i===currentLineIndex ? " current":"") + (li.jp ? " showjp":"");
      div.innerHTML = `<div class="t">${escapeHTML(li.text)}</div><div class="jp">${escapeHTML(li.jp||"")}</div>`;
      div.addEventListener("click", () => {
        if (li.t != null) jumpToLine(i);
        else highlight(i);
        translateLine(i);
      });
      listEl.appendChild(div);
    }
  }

  function pickLyricsForTrack(name){
    if (!lyricsByBase.size){
      lyricLines = [];
      renderList();
      setStatus("LYRICS: NONE (load .lrc or .txt)");
      return false;
    }

    const base = baseName(name);
    let txt = lyricsByBase.get(base);

    if (!txt && lyricsByBase.size === 1){
      txt = Array.from(lyricsByBase.values())[0];
      setStatus("LYRICS: using the only file");
    }

    if (!txt){
      const nk = normalizeKey(name);
      let bestKey = null;
      let bestLen = 0;
      for (const k of lyricsByBase.keys()){
        const lk = normalizeKey(k);
        if (!lk) continue;
        if (lk === nk){
          bestKey = k; bestLen = lk.length; break;
        }
        if (nk.includes(lk) || lk.includes(nk)){
          const L = Math.min(lk.length, nk.length);
          if (L > bestLen){
            bestLen = L;
            bestKey = k;
          }
        }
      }
      if (bestKey) txt = lyricsByBase.get(bestKey);
    }

    if (!txt){
      lyricLines = [];
      renderList();
      setStatus("LYRICS: NO MATCH (rename lyrics file to match track name)");
      return false;
    }

    lyricLines = parseLyrics(txt);
    currentLineIndex = -1;
    renderList();
    setStatus(`LYRICS LOADED: ${lyricLines.length} lines`);
    // If plain-text lyrics, show first line
    if (lyricLines.length && lyricLines[0].t == null){
      highlight(0);
      if (onlineJP) translateLine(0);
    }
    return true;
  }

  function importLyricsFiles(files){
    let n = 0;
    for (const f of files){
      const ext = (f.name.split(".").pop() || "").toLowerCase();
      if (ext !== "lrc" && ext !== "txt") continue;
      n++;
      const reader = new FileReader();
      reader.onload = () => {
        const txt = String(reader.result || "");
        lyricsByBase.set(baseName(f.name), txt);
        setStatus(`LYRICS READY: ${lyricsByBase.size} files`);
        if (trackIndex>=0) pickLyricsForTrack(tracks[trackIndex].name);
      };
      reader.readAsText(f);
    }
    if (!n) setStatus("NO LYRICS FOUND");
  }

  function rebuildTrackSelect(){
    selTrack.innerHTML = '<option value="">TRACK: (未選択)</option>';
    tracks.forEach((t, i) => {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = t.name.split("/").pop();
      selTrack.appendChild(opt);
    });
    if (trackIndex>=0) selTrack.value = String(trackIndex);
  }

  function importAudioFiles(files){
    const list = [];
    for (const f of files){
      const name = f.webkitRelativePath ? f.webkitRelativePath : f.name;
      if (!f.type.startsWith("audio/") && !/\.(mp3|m4a|aac|wav|flac|ogg)$/i.test(name)) continue;
      list.push({ name, url: URL.createObjectURL(f) });
    }
    if (!list.length){
      setStatus("NO AUDIO FOUND");
      return;
    }
    tracks = list;
    trackIndex = 0;
    rebuildTrackSelect();
    setStatus(`FILES LOADED: ${tracks.length}`);
    selectTrack(0, false);
  }

  function selectTrack(i, autoPlay){
    if (i<0 || i>=tracks.length) return;
    trackIndex = i;
    rebuildTrackSelect();
    const tr = tracks[trackIndex];
    audio.pause();
    audio.src = tr.url;
    audio.load();
    curEn.textContent = "TAP A LINE TO TRANSLATE";
    curJp.textContent = "";
    currentLineIndex = -1;
    pickLyricsForTrack(tr.name);
    setStatus(`TRACK: ${tr.name.split("/").pop()}`);
    if (autoPlay) safePlay();
  }

  async function safePlay(){
    try{
      await audio.play();
      setStatus(`PLAYING: ${tracks[trackIndex]?.name.split("/").pop() || ""}`);
      return true;
    }catch(e){
      const msg = String(e?.message || e || "");
      setStatus("PLAY FAILED: " + msg);
      alert("再生できません: " + msg + "\n\n(一度画面をタップしてからPLAYを押してください)");
      return false;
    }
  }

  function findLineIndexByTime(t){
    if (!lyricLines.length) return -1;
    if (lyricLines[0].t == null) return -1; // plain text
    let lo=0, hi=lyricLines.length-1, ans=-1;
    while (lo<=hi){
      const mid=(lo+hi)>>1;
      if (lyricLines[mid].t <= t){ ans=mid; lo=mid+1; }
      else hi=mid-1;
    }
    return ans;
  }

  function highlight(i){
    if (i===currentLineIndex) return;
    currentLineIndex = i;
    Array.from(listEl.children).forEach((el, idx) => {
      el.classList.toggle("current", idx===i);
    });
    if (i>=0 && lyricLines[i]){
      curEn.textContent = lyricLines[i].text;
      if (onlineJP) translateLine(i);
    }
  }

  function jumpToLine(i){
    if (!lyricLines[i] || lyricLines[i].t == null) return;
    audio.currentTime = Math.max(0, lyricLines[i].t + 0.01);
    highlight(i);
  }

  async function translateText(en){
    const url = "https://api.mymemory.translated.net/get?q=" + encodeURIComponent(en) + "&langpair=en|ja";
    const res = await fetch(url, { cache:"no-store" });
    const data = await res.json();
    const jp = data?.responseData?.translatedText;
    return (jp && typeof jp==="string") ? jp : "";
  }

  function updateRowJP(i){
    const row = listEl.children[i];
    if (!row) return;
    const jpEl = row.querySelector(".jp");
    if (!jpEl) return;
    jpEl.textContent = lyricLines[i].jp || "";
    row.classList.toggle("showjp", !!lyricLines[i].jp);
  }

  async function translateLine(i){
    if (!onlineJP) return;
    const li = lyricLines[i];
    if (!li || !li.text) return;

    if (li.jp){
      curJp.textContent = li.jp;
      updateRowJP(i);
      return;
    }
    curJp.textContent = "TRANSLATING...";
    try{
      const jp = await translateText(li.text);
      li.jp = jp || "";
      curJp.textContent = li.jp || "";
      updateRowJP(i);
    }catch(e){
      curJp.textContent = "";
      setStatus("TRANSLATE FAILED (try OPEN)");
    }
  }

  function openTranslate(){
    const en = (curEn.textContent || "").trim();
    if (!en || en === "TAP A LINE TO TRANSLATE") return;
    const url = "https://translate.google.com/?sl=en&tl=ja&text=" + encodeURIComponent(en) + "&op=translate";
    window.open(url, "_blank");
  }

  function copyCurrent(){
    const en = (curEn.textContent || "").trim();
    const jp = (curJp.textContent || "").trim();
    const txt = jp ? (en + "\n" + jp) : en;
    navigator.clipboard?.writeText(txt).catch(()=>{});
    setStatus("COPIED");
  }

  // --- Events
  btnOnline.addEventListener("click", () => {
    onlineJP = !onlineJP;
    btnOnline.textContent = "ONLINE JP: " + (onlineJP ? "ON" : "OFF");
    btnOnline.classList.toggle("on", onlineJP);
    if (!onlineJP){
      curJp.textContent = "";
      Array.from(listEl.children).forEach(el => el.classList.remove("showjp"));
      return;
    }
    if (currentLineIndex>=0) translateLine(currentLineIndex);
  });

  btnList.addEventListener("click", () => {
    listOn = !listOn;
    listEl.style.display = listOn ? "block" : "none";
    btnList.textContent = "LIST: " + (listOn ? "ON" : "OFF");
  });

  inFolder.addEventListener("change", () => {
    const files = Array.from(inFolder.files || []);
    importAudioFiles(files);
    importLyricsFiles(files);
    inFolder.value = "";
  });

  inAudio.addEventListener("change", () => {
    importAudioFiles(Array.from(inAudio.files || []));
    inAudio.value = "";
  });

  inLyrics.addEventListener("change", () => {
    importLyricsFiles(Array.from(inLyrics.files || []));
    inLyrics.value = "";
  });

  selTrack.addEventListener("change", () => {
    const v = selTrack.value;
    if (v === "") return;
    selectTrack(Number(v), false);
  });

  btnPlay.addEventListener("click", async () => {
    if (!tracks.length){ alert("まずFILESで音声ファイルを選択してください。"); return; }
    if (audio.paused) await safePlay();
    else { audio.pause(); setStatus("PAUSED"); }
  });

  btnPrev.addEventListener("click", () => {
    if (!tracks.length) return;
    selectTrack((trackIndex-1+tracks.length)%tracks.length, true);
  });

  btnNext.addEventListener("click", () => {
    if (!tracks.length) return;
    selectTrack((trackIndex+1)%tracks.length, true);
  });

  btnOpen.addEventListener("click", openTranslate);
  btnCopy.addEventListener("click", copyCurrent);

  audio.addEventListener("timeupdate", () => {
    const i = findLineIndexByTime(audio.currentTime);
    if (i>=0) highlight(i);
  });

  audio.addEventListener("error", () => {
    setStatus("AUDIO ERROR (format not supported)");
  });

  // Initial UI
  listEl.style.display = "block";
  setStatus("READY (OneFileReset v2)");
  btnOnline.classList.toggle("on", onlineJP);
})();
</script>

</body>
</html>
